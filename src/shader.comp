
#version 450

layout (local_size_x = 1, local_size_y = 1) in;

layout (set = 0, binding = 0) uniform writeonly image2D image;

layout (binding = 1) uniform CamInfo{
    vec4 pos;
    mat4 rot;
} camInfo;

void main(){
	const float aspectRatio = float(gl_NumWorkGroups.x) / float(gl_NumWorkGroups.y);
	const vec2 screenSpaceLocation = vec2(
		(float(gl_WorkGroupID.x) / float(gl_NumWorkGroups.x) * 2 - 1) * aspectRatio,
		float(gl_WorkGroupID.y) / float(gl_NumWorkGroups.y) * -2 + 1
		);
	const vec3 rayDirection = vec3(camInfo.rot * normalize(vec4(screenSpaceLocation, 1, 1)));
    const vec3 pos = vec3(camInfo.pos);

    int xStep;
    if (rayDirection.x > 0){
        xStep = 1;
    }else if(rayDirection.x < 0){
        xStep = -1;
    }else{
        xStep = 0;
    }

    int yStep;
    if (rayDirection.y > 0){
        yStep = 1;
    }else if(rayDirection.y < 0){
        yStep = -1;
    }else{
        yStep = 0;
    }

    int zStep;
    if (rayDirection.z > 0){
        zStep = 1;
    }else if(rayDirection.z < 0){
        zStep = -1;
    }else{
        zStep = 0;
    }

    float tMaxX = abs(1 / rayDirection.x);
    float tMaxY = abs(1 / rayDirection.y);
    float tMaxZ = abs(1 / rayDirection.z);

    float t = 0;

    if (tMaxX < tMaxY){
        if(tMaxX < tMaxZ){
            // X
            t += tMaxX;
        }else{
            // Z
            t += tMaxZ;
        }
    }else{
        if(tMaxY < tMaxZ){
            // Y
            t += tMaxY;
        }else{
            // Z
            t += tMaxZ;
        }
    }

	vec3 color = vec3(t / 5, t / 5, t / 5);

	imageStore( image, ivec2(gl_WorkGroupID.xy), vec4(color, 1.0) );
}