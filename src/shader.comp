
#version 450

layout (local_size_x = 1, local_size_y = 1) in;

layout (set = 0, binding = 0) uniform writeonly image2D image;

layout (binding = 1) uniform CamInfo{
    vec4 pos;
    mat4 rot;
} camInfo;

int RayHitFace(vec3 rayOrigin, vec3 rayDirection, vec3 facePosition, float faceSize)
{
    // Get triangle side vectors
    vec3 tu = vec3(faceSize,0,0);   // Triangle U component
    vec3 tv = vec3(0,faceSize,0);   // Triangle V component

    // Determinant for inverse matrix
    vec3 q = cross(rayDirection, tv);
    float det = dot(tu, q);
    if(abs(det) < 0.0000001){
    	return 0;
	}
    float invdet = 1.0/det;

    // Solve component parameters
    vec3 s = rayOrigin - facePosition;
    float u = dot(s, q) * invdet;
    if(u < 0.0 || u > 1.0)
        return 0;

    vec3 r = cross(s, tu);
    float v = dot(rayDirection, r) * invdet;
    if(v < 0.0 || v > 1.0)
        return 0;

    float t = dot(tv, r) * invdet;
    if(t <= 0.0)
        return 0;

    return 1;
}

void main(){
	const float aspectRatio = float(gl_NumWorkGroups.x) / float(gl_NumWorkGroups.y);
	const vec2 screenSpaceLocation = vec2(
		(float(gl_WorkGroupID.x) / float(gl_NumWorkGroups.x) * 2 - 1) * aspectRatio,
		float(gl_WorkGroupID.y) / float(gl_NumWorkGroups.y) * -2 + 1
		);
	const vec3 rayDirection = vec3(camInfo.rot * normalize(vec4(screenSpaceLocation, 1, 1)));
    const vec3 pos = vec3(camInfo.pos);

	vec3 color;
	if (RayHitFace(pos, rayDirection, vec3(0, 0, 5), 1) == 1){
		color = vec3(0.0, 0.0, 1.0);
	}else{
		color = vec3(0.1, 0.0, 0.0);
	}

	imageStore( image, ivec2(gl_WorkGroupID.xy), vec4(color, 1.0) );
}